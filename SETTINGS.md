
# ⚙️ Critical Project Settings

Сохраните эти настройки. Они критически важны для работы авторизации, интеграции с Google Drive и стабильности UI.

## 1. Clerk Dashboard (Authentication)
*   **Mode**: Development (`pk_test_...`)
*   **Social Connections** -> **Google** (Шестеренка ⚙️):
    *   **Use custom credentials**: ✅ **ВКЛЮЧЕНО** (Обязательно для Dev режима)
    *   **Client ID**: ID из Google Cloud Console
    *   **Client Secret**: Secret из Google Cloud Console
    *   **Scopes**:
        *   `email`
        *   `profile`
        *   `https://www.googleapis.com/auth/drive.file` (Критично для загрузки файлов)

## 2. Google Cloud Console
*   **Project Status**: Production (Рекомендуется, чтобы токены жили дольше 7 дней) или Testing.
*   **APIs & Services** -> **Enabled APIs**:
    *   Google Drive API
*   **Credentials** -> **OAuth 2.0 Client IDs**:
    *   **Authorized JavaScript origins**: `http://localhost:5173`, `https://ващ-домен.vercel.app`
    *   **Authorized redirect URIs**: Ссылка из Clerk Dashboard (обычно `https://clerk.ващ-домен.com/v1/oauth/callback`)

## 3. Environment Variables (.env)
*   `VITE_CLERK_PUBLISHABLE_KEY`: Ваш ключ Clerk (`pk_test_...`)
*   `CLERK_SECRET_KEY`: Ваш секретный ключ Clerk (`sk_test_...`)
*   `BLOB_READ_WRITE_TOKEN`: Токен Vercel Blob (для резервного хранилища)
*   `POSTGRES_URL`: Строка подключения к Vercel Postgres

## 4. Особенности работы (Troubleshooting)
*   **Sync Error в профиле**: Означает, что токен Google устарел или отозван.
    *   *Решение*: Нажать "Repair Connection" или полностью выйти (Logout) и зайти снова.
*   **Черный экран видео**: Обычно из-за ограничений Google Drive на прямые ссылки.
    *   *Решение*: Файлы должны иметь доступ "Anyone with the link can view". Приложение делает это автоматически при загрузке.

## 5. Железные Правила Воспроизведения (Video Playback Hard Rules)
**⚠️ КРИТИЧЕСКИ ВАЖНО. НЕ ИЗМЕНЯТЬ БЕЗ СОГЛАСОВАНИЯ ⚠️**

Для стабильного воспроизведения видео с Google Drive в HTML5 плеере (`<video>`) необходимо соблюдать три условия. Любое отклонение приведет к ошибке `403 Forbidden` или невозможности перемотки.

### 1. Формат Ссылки (URL Format)
*   **ОБЯЗАТЕЛЬНО**: Использовать "Legacy" формат экспорта:
    `https://drive.google.com/uc?export=download&confirm=t&id={FILE_ID}`
*   **ЗАПРЕЩЕНО**: Использовать API v3 (`googleapis.com/drive/v3/files/...`) с заголовком `Authorization`.
    *   *Причина*: Браузер отправляет `OPTIONS` запрос (preflight) перед загрузкой видео. Google API для эндпоинта `/files` часто блокирует заголовки `Range` (необходимые для перемотки) в CORS-ответах, если передается токен авторизации. Ссылки формата `uc?export=download` работают через стандартные Cookie/Public access и поддерживают Byte-Range запросы.

### 2. Атрибут CORS (Cross-Origin Attribute)
*   **ОБЯЗАТЕЛЬНО**: В компоненте `Player.tsx`, тег `<video>` **НЕ ДОЛЖЕН** иметь атрибут `crossOrigin="anonymous"`.
    ```tsx
    // ✅ Правильно
    <video src={driveUrl} ... />

    // ❌ Ошибка (Видео не загрузится с Drive)
    <video src={driveUrl} crossOrigin="anonymous" ... />
    ```
    *   **Причина**: Google Drive в режиме `uc?export=download` редко отдает корректные заголовки `Access-Control-Allow-Origin`, даже если файл публичный. Установка `crossOrigin="anonymous"` заставляет браузер строго требовать эти заголовки, что приводит к блокировке загрузки. Без этого атрибута видео загружается в режиме "opaque", что разрешает воспроизведение (хотя и запрещает чтение пикселей через Canvas, но для плеера это допустимо).

### 3. Авто-исправление Прав (Permissions Auto-Heal)
*   В `Player.tsx` реализована логика "самолечения":
    1.  При ошибке загрузки (`onError`) проверяется статус файла.
    2.  Если файл существует, но не грузится -> вызывается `GoogleDriveService.makeFilePublic(id)`.
    3.  После успешного исправления прав ссылка обновляется с параметром `&retry={timestamp}`.
    4.  **Важно**: Попытка исправления выполняется **ТОЛЬКО ОДИН РАЗ** за сессию (используется `useRef(permissionFixAttempted)`), чтобы избежать бесконечного цикла перезагрузок страницы.

## 6. S3 & BYOS Configuration
При использовании собственного хранилища (Yandex/Selectel/R2) необходимо настроить CORS.

**Эталонная конфигурация CORS (JSON):**
```json
[
  {
    "AllowedHeaders": ["*"],
    "AllowedMethods": ["GET", "PUT", "HEAD", "POST", "DELETE"],
    "AllowedOrigins": ["*"],
    "ExposeHeaders": ["ETag", "x-amz-meta-custom-header"],
    "MaxAgeSeconds": 3000
  }
]
```
Приложение может применить эту конфигурацию автоматически через кнопку "Auto-CORS" в профиле, если у сервисного аккаунта есть права администратора бакета.

## 7. Архитектура Плеера (Video Player Core)
**⚠️ ЛОГИКА ТАЙМКОДА И СКРАББИНГА ⚠️**

При рефакторинге компонента `Player.tsx` соблюдать следующие правила:

*   **Определение FPS (FPS Detection)**:
    *   **ОБЯЗАТЕЛЬНО**: Плеер должен автоматически определять реальную частоту кадров воспроизводимого файла (используя анализ дельты времени между кадрами `requestAnimationFrame` или метаданные, если доступны).
    *   **ОБЯЗАТЕЛЬНО**: В интерфейсе плеера (рядом с таймкодом) должна отображаться **актуальная частота кадров** (например, `23.98 FPS`, `25 FPS`, `60 FPS`).
    *   **Запрещено**: Жестко кодировать FPS (например, всегда 24) для расчета таймкода, если видео имеет другую частоту. Это приводит к рассинхрону комментариев.

*   **Расчет Таймкода (Timecode Calculation)**:
    *   **Метод**: Всегда считать через **общее количество кадров** (Total Frames).
    *   **Формула**: `const totalFrames = Math.floor(seconds * videoFps);`
    *   **Кадры**: `const ff = totalFrames % videoFps;`
    *   **ЗАПРЕЩЕНО**: Использовать остаток от деления секунды `Math.floor((seconds % 1) * fps)`.
    *   **Причина**: Ошибки плавающей запятой (floating point errors) приводят к тому, что 24-й кадр может отобразиться как 23-й или перескочить, вызывая рассинхрон с EDL/XML экспортом.

*   **Логика Скраббинга (Scrubbing) и "Мертвая Зона"**:
    *   **Таймлайн (Timeline Bar)**: Использует **Абсолютное** позиционирование. Клик/Драг устанавливает время пропорционально ширине (`percentage * duration`).
    *   **Область Видео (Video Overlay)**: Использует **Относительное** позиционирование (Precision Scrubbing).
        *   **Флаг Нажатия**: Используйте `ref.current.isPressed` для отслеживания состояния кнопки мыши.
        *   **Алгоритм Мертвой Зоны (Dead Zone)**:
            1.  `PointerDown`: Установить `isPressed = true`, `isDragging = false`, запомнить `startX`. Не ставить паузу.
            2.  `PointerMove`:
                *   Если `!isPressed`, немедленный `return` (игнорировать простое движение мыши/ховер).
                *   Если `!isDragging` и `Math.abs(currentX - startX) < 10px`, `return` (игнорировать микро-движения).
                *   Если порог превышен: `isDragging = true`, поставить **Pause**, начать менять время.
            3.  `PointerUp`:
                *   Если `!isDragging` (движения не было), выполнить `togglePlay()` (считать кликом).
                *   Сбросить `isPressed` и `isDragging`.
        *   **Чувствительность**: `5 пикселей = 1 кадр`.

## 8. Versioning & Naming (Правила именования версий)
*   При загрузке новой версии к существующему ассету (`useUploadManager.ts`):
    *   **ЗАПРЕЩЕНО** использовать имя загружаемого файла (например, `Cut_Final_v2.mp4`).
    *   **ОБЯЗАТЕЛЬНО** использовать название родительского Ассета + индекс версии.
    *   **Формат**: `{AssetTitle}_v{NextNumber}.{extension}`.
    *   **Пример**: Ассет `Reels-Hudenie` -> Файл `Reels-Hudenie_v2.mp4`.

## 9. Player UX Defaults (Поведение Плеера)
*   **Инициализация**:
    *   При открытии плеера **ВСЕГДА** загружать последнюю версию из списка (`versions.length - 1`), игнорируя сохраненный `currentVersionIndex` (если он устарел).
*   **Выпадающий список (Dropdown)**:
    *   Список версий должен иметь `z-index: 100` или выше.
    *   Родительский контейнер заголовка в `Player.tsx` не должен иметь `overflow: hidden`, чтобы список мог выпадать поверх видео.

## 10. Доступность в РФ (Cloudflare Settings)
**⚠️ КРИТИЧНО ДЛЯ РАБОТЫ В РОССИИ (RKN Bypass) ⚠️**

Для стабильной работы в РФ необходимо скрыть IP Vercel за прокси Cloudflare, но при этом отключить современные протоколы шифрования, которые блокируются ТСПУ (DPI).

**Настройки Cloudflare (Вкладка DNS):**

1.  **Проверка NS-серверов (В регистраторе домена):**
    *   Убедитесь, что домен делегирован на NS-серверы Cloudflare (например, `joselyn.ns.cloudflare.com`), а не Beget/Reg.ru.
    *   *Симптом ошибки:* В панели хостинга (Beget) написано "Домен делегирован сторонним DNS". Это хорошо! Значит, управляем через Cloudflare.

2.  **DNS Записи (CNAME Flattening):**
    *   `CNAME | @ | cname.vercel-dns.com` -> **Proxied (Оранжевое облако)**
    *   `CNAME | www | cname.vercel-dns.com` -> **Proxied (Оранжевое облако)**
    *   *Важно:* Удалите все `A` записи для корня (`@`), если используете CNAME Flattening. Это самый надежный способ.

3.  **Network (Вкладка Network):**
    *   **HTTP/3 (with QUIC)**: ⛔ **OFF**
    *   **0-RTT Connection Resumption**: ⛔ **OFF**
    *   **IPv6 Compatibility**: ⛔ **OFF** (Отключается через API/Консоль).

4.  **SSL/TLS (Вкладка Edge Certificates):**
    *   **TLS 1.3**: ⛔ **OFF** (Disabled).
    *   **Minimum TLS Version**: **1.2**.
    *   *Цель:* Отключение TLS 1.3 автоматически отключает **ECH**, который блокируется ТСПУ.

## 11. Admin UI Structure (Стратегия & Roadmap)
**⚠️ НЕ ИЗМЕНЯТЬ ЛОГИКУ UI БЕЗ ЗАПРОСА ⚠️**

Вкладка **"Стратегия"** в `AdminPanel.tsx` имеет специфическую жесткую структуру, согласованную с бизнес-целями:

1.  **S.M.A.R.T. Grid**: Четыре карточки (Specific, Measurable, Achievable, Relevant).
    *   *Данные:* Статичные константы (150 лицензий, 435к выручки). Не заменять на пустые динамические данные из БД.
2.  **Time-Bound**: Горизонтальная шкала (Месяц 1-3, 4-6, 7+).
3.  **Tactical Plan (Growth Hacking)**: Список чекбоксов с зеленым выделением выполненных задач.
    *   *Логика:* Этот список служит напоминанием для администратора и не должен быть удален при рефакторинге.

## 12. TypeScript & Class Components
При работе с компонентами-классами (особенно `ErrorBoundary.tsx`):

*   **Наследование**: Всегда использовать `extends React.Component<Props, State>`, а не просто `Component`. Это решает проблемы с видимостью типов `props` и `state` в строгом режиме TS + Vite.
*   **Инициализация State**: Использовать public field declaration (`public state: State = { ... }`) вместо конструктора для чистоты кода и типизации.

## 13. Payment Configuration (Backend)
*   Конфигурация платежей хранится в таблице `system_settings` под ключом `payment_config`.
*   Поля: `prices` (объект), `plans` (объект с деталями UI), `yookassa` (ключи), `prodamus` (ключи).
*   **Важно**: При изменении `api/payment.js` всегда проверять наличие фоллбэка на ENV переменные, если БД недоступна.

## 14. Dynamic Configuration & Pricing (Architecture)
**⚠️ Правила работы с динамическим конфигом UI ⚠️**

Система управления тарифами и флагами функций (`RoadmapBlock`, `Feature Flags`) работает по гибридной схеме:

1.  **Hardcoded Defaults (`types.ts`)**:
    *   В коде всегда должны быть актуальные дефолтные значения (`DEFAULT_PAYMENT_CONFIG`).
    *   *Цель*: Мгновенный рендер (SSR-like) и работа в случае падения базы данных.

2.  **Client-Side Fetching (`useEffect`)**:
    *   При загрузке компонента React делает запрос к `/api/admin?action=get_payment_config`.
    *   Полученные данные перезаписывают дефолтные.

3.  **No FOUC Rule (Запрет на мерцание)**:
    *   **ОБЯЗАТЕЛЬНО**: Компоненты, зависящие от конфига (например, карточки с ценами), должны иметь состояние `isLoading = true` при инициализации.
    *   Пока данные загружаются, отображать **Skeleton Loader** (серые блоки).
    *   Показывать контент только после завершения загрузки (или ошибки).
    *   *Зачем*: Чтобы пользователь не видел смену цены (например, с 0₽ на 2900₽) через секунду после захода на страницу.

4.  **Data Consistency**:
    *   Если меняете структуру `PlanConfig` в `types.ts` (например, добавляете новое поле в карточку тарифа), обязательно обновите `AdminPanel.tsx` для поддержки редактирования этого поля.
    *   В противном случае, при сохранении настроек из админки, новые поля могут затереться.

## 15. Стратегия Хранения (Storage Strategy & Free Tier)
**⚠️ НЕ ОТКЛЮЧАТЬ GOOGLE DRIVE ДЛЯ FREE ⚠️**

*   **Drive is Core Feature:** Интеграция с Google Drive должна быть включена для ВСЕХ пользователей, включая Free тариф.
*   **Причина:** Хранение файлов на Drive пользователя не стоит нам денег. Запрещать это бессмысленно и ломает воркфлоу, так как альтернативы (Vercel Blob) мы не предоставляем для видео.
*   **Ограничения Free:** Должны реализовываться через:
    *   Количество проектов (Лимиты).
    *   Функции экспорта (XML/CSV).
    *   Блокировку шеринга.
*   **ЗАПРЕЩЕНО:** Ставить `enabledForFree: false` в конфиге для `google_drive`, если не предусмотрено альтернативное бесплатное хранилище.

## 16. Логика Дашборда и Лимитов (Dashboard & Limits)
*   **Сегментация:** Список проектов в Дашборде **ОБЯЗАН** быть разделен на два массива:
    1.  **Owned (Мои):** `ownerId === currentUserId`.
    2.  **Shared (Чужие):** Проекты, где пользователь — гость или член команды. Не влияют на лимит.
*   **Лимиты:** Лимит на количество проектов (из конфига) применяется **ТОЛЬКО** к Owned проектам. Пользователь может иметь 100 доступных (Shared) проектов, даже на Free тарифе.
*   **Anti-Hardcode:** Лимит проектов **ЗАПРЕЩЕНО** хардкодить числом (например, `3`). Он должен браться из хука `useAppConfig` (`config.max_projects.limitFree`).

## 17. Контроль Доступа (Permissions & Sharing)
*   **Шеринг для Free:** Возможность делиться проектом (кнопки "Share", "Invite", "Copy Link") контролируется флагом `team_collab` в Админке.
*   **Поведение UI:**
    *   Если `team_collab.enabledForFree === false` и пользователь Free -> Скрывать или блокировать (disabled) кнопки шеринга.
    *   Это превращает Free тариф в "Solo Mode" (только личное использование).

## 18. Safe Sharing Architecture (Two-Level Access)
**⚠️ КРИТИЧНО ДЛЯ БЕЗОПАСНОСТИ ⚠️**

Мы используем двухуровневую систему шеринга в Дашборде (Modal с вкладками):

### A. Client Review (Public Link)
*   **Тип:** Stateless Guest Access.
*   **Суть:** Включение тумблера **Public Access** в проекте.
*   **Ссылка:** `anotee.com/?projectId=X`.
*   **Поведение:**
    *   Пользователь НЕ добавляется в базу данных (список `team`).
    *   Доступ работает, только пока тумблер включен.
    *   **Приватность:** API фильтрует поле `team`, возвращая пустой список, чтобы клиенты не видели email-адреса редакторов.
*   **Use Case:** Отправка готового проекта клиенту для просмотра без регистрации и лишних кликов.

### B. Invite Team (Full Access)
*   **Тип:** Stateful Member Access.
*   **Суть:** Ссылка с параметром `invite=true`.
*   **Ссылка:** `anotee.com/?projectId=X&invite=true`.
*   **Поведение:**
    *   При переходе пользователь **автоматически добавляется** в список `team` в базе данных.
    *   Получает роль `Viewer` (или выше, если настроено).
    *   Проект появляется у него в Дашборде навсегда.
*   **Use Case:** Приглашение коллег, монтажеров и постоянных сотрудников.

### C. Asset Review (Restricted)
*   **Тип:** Sandbox Access.
*   **Суть:** Ссылка на конкретный файл.
*   **Ссылка:** `anotee.com/?projectId=X&assetId=Y`.
*   **Поведение:**
    *   Пользователь добавляется в команду с полем `restrictedAssetId: Y`.
    *   API возвращает **только этот файл** (массив `assets` фильтруется на бэкенде).
*   **Use Case:** Показать один конкретный ролик из большого проекта.

## 19. Diagnostics Route (QA)
*   **URL:** `/test`
*   **Доступ:** Публичный (не требует авторизации в UI, но сами тесты могут проверять приватные API).
*   **Назначение:** Самодиагностика системы. Проверка интеграций (API, Billing, Storage, Auth) на стороне клиента.
*   **Скрытие:** Ссылка на этот роут доступна только в Админ-панели или при прямом вводе URL.
